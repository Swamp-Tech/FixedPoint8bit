#ifndef FIX_POINT_H 
#define FIX_POINT_H

/*
2024 (с) SwampTech

Реализует математику чисел с фиксированной точкой,
где для целой части используется 1 старший байт и 1 младший байт для дробной части.
Библиотека должна быть совместима с любыми 8-битными процессорами

Для связи пишите в ТГ-канал - https://t.me/Swamp_Tech

Целая часть хранится как есть, а дробная часть хранится в виде долей числа 256
Число 0x01_A3 - это число 1 + (163 / 256)

*/

#include "fix_point16/fix_point_types.h"
#include "fix_point16/macros.h"
// Таблица косинусов
#include "fix_point16/cos.h"
#include "fix_point16/sin.h"
// Таблица корней
#include "fix_point16/sqrt.h"

//
// Макросы ввода значений
//

// Преобразует Десятичную дробь в двоичную дробь с фиксированной точкой
// INT - целая часть, FRAC - дробная (3 разряда!!!), fix8_8 - ufix8_8 переменная
// FRAC = 3 - это 0,003 
// Писать DECIMAL(1,003,...) нельзя, 0 перед числом делает его восьмеричным
// FRAC = 123 - это 0,123
#define DECIMAL(INT,FRAC,FIX8_8) \
            FIX8_8 = ((INT << 8) | ( (FRAC * 256UL) / 1000UL ) )
// Возвращает число с фикс точкой fix8_8
// GET_DEC(3,45) - вернет (3.045)!
#define GET_DEC(INT,FRAC) \
            ((INT << 8) | ( (FRAC * 256UL) / 1000UL ) )
            
// Задает и возвращает число с фикс точкой в двоичном виде
// инт + (frac/256) - его десятичное значение
// Дробная часть хранится просто в виде frac
#define GET_BIN(INT,FRAC) \
            ((INT << 8) | FRAC)

//
// Прочие операции
//

// Инкремент переменной переменной с фиксированной точкой (8 бит дробная часть)
#define INC_FIX(X) (X += 256)

// Декремент переменной переменной с фиксированной точкой (8 бит дробная часть)
#define DEC_FIX(X) (X -= 256)

// Реализует сдвиг вправо на 8 бит через копирование байт
// Для 32-битных чисел
#define SHIFT_RIGHT_BY_8_BITS(N_32BIT) \
            GET_BYTE(N_32BIT) [0] = GET_BYTE(N_32BIT) [1]; \
            GET_BYTE(N_32BIT) [1] = GET_BYTE(N_32BIT) [2]; \
            GET_BYTE(N_32BIT) [2] = GET_BYTE(N_32BIT) [3]; \
            GET_BYTE(N_32BIT) [3] = 0

// Реализует сдвиг влево на 8 бит через копирование байт
// Старший байт уничтожается
// Для 32-битных чисел
#define SHIFT_LEFT_BY_8_BITS(N_32BIT) \
            GET_BYTE(N_32BIT) [3] = GET_BYTE(N_32BIT) [2]; \
            GET_BYTE(N_32BIT) [2] = GET_BYTE(N_32BIT) [1]; \
            GET_BYTE(N_32BIT) [1] = GET_BYTE(N_32BIT) [0]; \
            GET_BYTE(N_32BIT) [0] = 0; 


// Квадратный корень положительного целого числа от 0 до 255
// Аргумент может быть переменной или целочисленной константой
// Результат сохраняется в fix8_8
#define SQRT(X, fix8_8) \
            GET_BYTE(fix8_8) [0] = sqrt_frac [X]; \
            GET_BYTE(fix8_8) [1] = sqrt_int [X]

//
// Умножение
//

// Макрос беззнакового умножения A = X * Y 
// A - ufix24_8
// X, Y  - ufix8_8 или ufix24_8
#define MUL_UFIX(X, Y, A) \
            A = (ufix24_8)X * (ufix24_8)Y; \
            SHIFT_RIGHT_BY_8_BITS (A)

// Тут стандартный сдвиг, так как нужно учитывать знаковый бит
// A - fix24_8
// X, Y  - fix8_8 или fix24_8
#define MUL_FIX(X, Y, A) \
            A = (fix24_8)X * (fix24_8)Y; \
            A >>= 8

// Возведение числа в квадрат
#define SQUARE(X, RESULT) \
            RESULT = (fix24_8)X * (fix24_8)X; \
            RESULT >>= 8


//
// Деление
//
       
// Беззнаковое деление - С = X / Y
// A - uint32_t
// X, Y  - uint16_t or uint32_t
#define DIV_UFIX(X, Y, A) \
            GET_BYTE(A) [0] = 0; \
            GET_BYTE(A) [1] = GET_BYTE(X) [0]; \
            GET_BYTE(A) [2] = GET_BYTE(X) [1]; \
            GET_BYTE(A) [3] = 0;  \
            A /= (ufix8_8)Y
// Знаковое деление
#define DIV_FIX(X, Y, A) \
            GET_BYTE(A) [0] = 0; \
            GET_BYTE(A) [1] = GET_BYTE(X) [0]; \
            GET_BYTE(A) [2] = GET_BYTE(X) [1]; \
            if (GET_BYTE(X) [1] & 0x80)  \
                GET_BYTE(A) [3] = 0xFF; \
            else \
                GET_BYTE(A) [3] = 0; \
            A /= (fix24_8)Y

//
// Тригонометрия
//
//
// 1 двоичный градус = (90 * (1 / 256)) обычных градусов

// Переводит обычные градусы в двоичные градусы
// INT - целая часть
// FRAC - дробная (2 разряда!)
// FRAC = 3 - это 0,03
#define DEGREE(INT, FRAC) \
            ( ( (INT*100 + FRAC) * 256UL ) / 9000UL )

// Переводит обычные радианы в двоичные градусы
// Аналогично как и для градусов
#define RAD(INT, FRAC) \
            ( ( (INT*100 + FRAC) * 256UL ) / 157UL )

// Вычисляет косинус в градусах до 90 градусов
// Только до 90 градусов
#define COS_D(INT, FRAC) \
            cosines [DEGREE (INT, FRAC)]

// Вычисляет косинус в радианах до 90 градусов
// Только до 90 градусов
#define COS_R(INT, FRAC) \
            cosines [RAD (INT, FRAC)]
// Вычисляет косинус двоичных градусов
// 1 двоичный градус = 90/256 обычных градусов
// Только до 90 градусов
#define COS_B(B) \
            cosines [B]


// Вычисляет синус в градусах до 90 градусов
// Только до 90 градусов
#define SIN_D(INT, FRAC) \
            sinus [DEGREE (INT, FRAC)]

// Вычисляет синус в радианах до 90 градусов
// Только до 90 градусов
#define SIN_R(INT, FRAC) \
            sinus [RAD (INT, FRAC)]
// Вычисляет синус двоичных градусов
// 1 двоичный градус = (90/256) обычных градусов
// Только до 90 градусов
#define SIN_B(B) \
            sinus [B]


//
// Числовые константы
//

// M_E — основание натурального логарифма (e).
// 2 + (184/256) 
#define M_E (GET_BIN (2, 184))

// Число π (пи) 
#define M_PI (GET_BIN (3, 36))
// Число π/2 (пи) 
#define M_PI_2 (GET_BIN (1, 146))
// Число π/4 (пи) 
#define M_PI_4 (GET_BIN (0, 201))

// Квадратный корень из (2)
#define M_SQRT2 (GET_BIN (1, 106))


#endif